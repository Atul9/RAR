use nom;
use header::{Header, header};


/// Encryption header
#[derive(PartialEq, Debug)]
pub struct EncryptionBlock {
    pub head: Header,
}

pub fn get_encryption_block(inp: &[u8]) -> nom::IResult<&[u8], EncryptionBlock> {
    // get the base header
    let (input, head) = header(inp)?;

    let encr = EncryptionBlock {
        head
    };

    Ok((input, encr))
}

#[test]
#[ignore]
fn test_get_encryption_block() {
    /*let data = [
        0x9B, 0x1E, 0x96, 0x97, 0x0C, 0x01, 0x05, 0x08,    
        0x00, 0x07, 0x01, 0x01, 0xFC, 0xA7, 0x83, 0x81, 0x00, 0x7C, 0x43, 0x43, 0x68, 0x5C, 0x02, 0x03,    
        0x3C, 0xE0, 0x95, 0x83, 0x81, 0x00, 0x04, 0xDB, 0x95, 0x83, 0x81, 0x00, 0x20, 0x17, 0x79, 0x1F,
    ];*/

    let data = [
        0xA2, 0x18, 0xB4, 0xAA, 0x3D, 0x1C, 0x14, 0x2B, 0x5C, 0x55, 0x02,    
        0x03, 0x3C, 0xD0, 0x10, 0x04, 0xC6, 0x10, 0x20, 0xEA, 0x8E, 0x03, 0x71, 0x80, 0x00, 0x00, 0x08,    
        0x74, 0x65, 0x78, 0x74, 0x2E, 0x74, 0x78, 0x74, 0x30, 0x01, 0x00, 0x03, 0x0F, 0x91, 0x36, 0x5C,    
        0xDE, 0x8E, 0x8E, 0x0D, 0x13, 0xFF, 0xBA, 0x80, 0xE9, 0x2B, 0x5F, 0x08, 0x4A, 0xD1, 0xD8, 0x56,   
        0x5E, 0x98, 0x7A, 0xF0, 0xF7, 0x68, 0x38, 0x01, 0x5B, 0x05, 0xF6, 0x5B, 0x8E, 0x08, 0xF2, 0xD8,    
        0xB3, 0x20, 0x71, 0x84, 0x52, 0x92, 0x19, 0x56, 0x11, 0x0A, 0x03, 0x02, 0x78, 0x27, 0x3C, 0x1E,
    ];

    let mut header_flags = ::header::Flags::new();
    header_flags.extra_area = true;

    let mut encr = EncryptionBlock {
        head: Header::new(1382117921, 26, ::header::Typ::MainArchive, header_flags),
    };

    assert_eq!(get_encryption_block(&data), Ok((&data[8..][..], encr)));
}